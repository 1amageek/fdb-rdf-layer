# fdb-rdf-layer: 設計比較レビュー

**Date:** 2025-10-30
**Purpose:** 既存設計（v1.2）と新設計（v2.0）を客観的に比較し、最終設計を決定する

---

## 📊 比較サマリー

| 観点 | 既存設計（v1.2） | 新設計（v2.0） | 推奨 |
|------|------------------|----------------|------|
| **複雑さ** | ⭐⭐⭐ (高) | ⭐⭐⭐⭐⭐ (低) | 🟢 新設計 |
| **書き込み性能** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ (+33%) | 🟢 新設計 |
| **クエリ性能** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 既存設計 |
| **保守性** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🟢 新設計 |
| **拡張性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 既存設計 |
| **実装工数** | ⭐⭐ (8週) | ⭐⭐⭐⭐⭐ (2週) | 🟢 新設計 |

**総合評価:** 🏆 **新設計（v2.0）を推奨** （詳細は後述）

---

## 1. アーキテクチャの比較

### 1.1 コンポーネント構成

#### 既存設計（v1.2）

```
RDFStore
  ↓
MetadataManager ←┐
  ↓              │
OnlineIndexBuilder
  ├─ RangeSet
  └─ IndexingThrottle
  ↓
QueryPlanner → IndexManager → DictionaryStore
  ↓             ↓               ↓
     SubspaceManager
```

**Actor数:** 6 (RDFStore, MetadataManager, IndexManager, QueryPlanner, DictionaryStore, OnlineIndexBuilder)
**Struct数:** 2 (SubspaceManager, IndexingThrottle)
**推定行数:** ~3,000行

#### 新設計（v2.0）

```
RDFStore
  ↓
TripleStorage (統合)
  - Dictionary
  - 4 Indexes
  - Metadata
  - IndexBuilder
```

**Actor数:** 2 (RDFStore, TripleStorage)
**Struct数:** 1 (IndexBuilder - 将来)
**推定行数:** ~1,500行

### 1.2 複雑さの比較

| メトリクス | 既存設計 | 新設計 | 差分 |
|-----------|----------|--------|------|
| **Actorの数** | 6 | 2 | **-67%** ✅ |
| **ファイルの数** | ~10 | ~5 | **-50%** ✅ |
| **抽象化レイヤー** | 4層 | 2層 | **-50%** ✅ |
| **コード行数（推定）** | 3,000 | 1,500 | **-50%** ✅ |
| **依存関係** | 複雑（循環あり） | シンプル（一方向） | ✅ |

**評価:** 🟢 **新設計が圧倒的にシンプル**

---

## 2. インデックス戦略の比較

### 2.1 インデックス数

| 設計 | インデックス | 総数 |
|------|--------------|------|
| **既存設計** | SPO, SOP, PSO, POS, OSP, OPS | 6 |
| **新設計** | SPO, PSO, POS, OSP | 4 |

### 2.2 クエリパターンのカバレッジ

| クエリパターン | 頻度(推定) | 既存設計 | 新設計 | 影響 |
|---------------|-----------|----------|--------|------|
| `(s, ?, ?)` | 30% | SPO | SPO | ✅ 同等 |
| `(?, p, ?)` | 25% | PSO | PSO | ✅ 同等 |
| `(?, ?, o)` | 20% | OSP | OSP | ✅ 同等 |
| `(s, p, ?)` | 15% | SPO | SPO | ✅ 同等 |
| `(?, p, o)` | 10% | POS | POS | ✅ 同等 |
| **`(s, ?, o)`** | **~3%** | **SOP** | **SPO+filter** | ⚠️ **やや劣化** |
| `(?, ?, ?)` | ~2% | Any | SPO | ✅ 同等 |

### 2.3 パフォーマンス影響の分析

#### 書き込み性能

```
既存設計: 1トリプル挿入 = 6インデックス書き込み
新設計:   1トリプル挿入 = 4インデックス書き込み

改善: +33% スループット向上 ✅
```

**実測推定:**
- 既存設計: ~40,000 トリプル/秒
- 新設計: ~53,000 トリプル/秒

#### クエリ性能

**ケース1: 主要パターン（97%）**
```
既存設計: O(log N) - 直接インデックス
新設計:   O(log N) - 直接インデックス

結果: 同等 ✅
```

**ケース2: (s, ?, o) パターン（3%）**
```
既存設計: O(log N) - SOP直接スキャン
新設計:   O(K log N) - SPOスキャン + フィルタリング
          K = Subjectあたりのトリプル数（平均10-50）

結果: 10-50倍遅い ⚠️
```

**影響評価:**
- 全体の3%のクエリが10-50倍遅くなる
- **ただし:** 絶対値では依然として高速（< 10ms）
- **重要度:** このパターンの使用頻度は実際には1%未満と予想

#### ストレージ

```
既存設計: トリプルあたり 6キー × 24バイト = 144バイト
新設計:   トリプルあたり 4キー × 24バイト = 96バイト

削減: 33% ストレージ削減 ✅
```

### 2.4 インデックス戦略の評価

| 観点 | 既存設計 | 新設計 | 評価 |
|------|----------|--------|------|
| **書き込み速度** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ (+33%) | 🟢 新設計 |
| **主要クエリ** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ (同等) | 🟡 同等 |
| **稀なクエリ** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ (-10x) | 🟡 既存設計 |
| **ストレージ** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ (-33%) | 🟢 新設計 |

**総合評価:** 🟢 **新設計を推奨**

理由：
- ✅ 97%のクエリで性能同等
- ✅ 書き込み33%高速化
- ✅ ストレージ33%削減
- ⚠️ 3%のクエリで劣化（ただし許容範囲）

---

## 3. オンラインインデックス構築の比較

### 3.1 既存設計（RangeSet + IndexingThrottle）

**コンポーネント:**
- `RangeSet`: 進捗追跡（FDBに状態保存）
- `IndexingThrottle`: 適応的スロットリング
- `OnlineIndexBuilder`: オーケストレーション

**推定行数:** ~800行

**機能:**
- ✅ 中断・自動再開
- ✅ 並行ビルド対応
- ✅ 動的スロットリング
- ✅ プログレス追跡

**複雑さ:** ⭐⭐ (高)

### 3.2 新設計（シンプルなチャンク処理）

**コンポーネント:**
- `IndexBuilder`: チャンクベース処理

**推定行数:** ~100行

**機能:**
- ❌ 中断・自動再開なし
- ❌ 並行ビルド非対応
- ✅ 固定スロットリング
- ✅ シンプルなプログレス

**複雑さ:** ⭐⭐⭐⭐⭐ (低)

### 3.3 実用性の評価

| シナリオ | 既存設計 | 新設計 | 評価 |
|---------|----------|--------|------|
| **1億トリプルのインデックス構築** | 15分 | 17分 | 🟡 ほぼ同等 |
| **プロセスクラッシュ** | 自動再開 ✅ | 手動再開 ⚠️ | 🟡 既存設計 |
| **複数インスタンスビルド** | 対応 ✅ | 非対応 ❌ | 🟡 既存設計 |
| **実装・メンテナンス** | 複雑 | シンプル | 🟢 新設計 |

### 3.4 現実的なユースケース分析

**質問:** オンラインインデックス構築は本当に必要か？

#### シナリオA: 初回データロード
```
状況: 空のストアに1億トリプルをロード
既存設計: インデックスをBUILDINGで開始、並行構築
新設計: 全インデックスをREADYで開始、insertBatch使用

結果: 新設計の方が高速（並行書き込み不要）
評価: 🟢 新設計が優位
```

#### シナリオB: 運用中に新インデックス追加
```
状況: 既存1億トリプルに5番目のインデックス追加
既存設計: バックグラウンドで構築、中断・再開可能
新設計: IndexBuilderで17分、中断時は手動再開

頻度: 年に1回程度
影響: 17分のダウンタイムは許容可能
評価: 🟡 両設計とも許容範囲
```

#### シナリオC: データセンター障害
```
状況: インデックス構築中にDC障害、別DCで再開
既存設計: RangeSetから自動再開
新設計: 最初からやり直し（17分）

頻度: 数年に1回
影響: 17分の遅延は許容可能
評価: 🟡 両設計とも許容範囲
```

### 3.5 オンラインインデックス構築の評価

| 観点 | 既存設計 | 新設計 | 推奨 |
|------|----------|--------|------|
| **機能の豊富さ** | ⭐⭐⭐⭐⭐ | ⭐⭐ | 🟡 既存設計 |
| **実用性** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 同等 |
| **実装コスト** | ⭐⭐ (8倍) | ⭐⭐⭐⭐⭐ | 🟢 新設計 |
| **保守コスト** | ⭐⭐ | ⭐⭐⭐⭐⭐ | 🟢 新設計 |

**総合評価:** 🟢 **新設計を推奨**

理由：
- ✅ 実用上の差は小さい（17分 vs 15分）
- ✅ 実装コストが8分の1
- ✅ 保守が容易
- ⚠️ 高度な機能が必要になったらPhase 6で追加可能

---

## 4. 保守性の比較

### 4.1 コードの理解しやすさ

#### 既存設計
```swift
// 6つのActorを跨ぐデータフロー
RDFStore
  → MetadataManager.getIndexStates()
  → IndexManager.insertTriple()
  → DictionaryStore.getOrCreateID()
  → SubspaceManager.encodeTripleKey()
```

**課題:**
- 🔴 データフローが複数のActorを跨ぐ
- 🔴 各Actorの責任境界が不明確
- 🔴 デバッグ時に6つのファイルを開く必要

#### 新設計
```swift
// 単一のActorで完結
RDFStore
  → TripleStorage.insert()
      - getOrCreateID() (private)
      - encodeTripleKey() (private)
      - insertToIndexes() (private)
```

**利点:**
- ✅ データフローが1つのActor内で完結
- ✅ private関数で責任が明確
- ✅ デバッグ時に1-2ファイルのみ

### 4.2 テストのしやすさ

| テストケース | 既存設計 | 新設計 | 評価 |
|-------------|----------|--------|------|
| **単体テスト** | 6 Actors × 平均5テスト = 30ケース | 1 Actor × 10テスト = 10ケース | 🟢 新設計 |
| **統合テスト** | Actor間の相互作用を全テスト | 単一Actorで完結 | 🟢 新設計 |
| **モック** | 5つのActorをモック | モック不要 | 🟢 新設計 |

### 4.3 変更の影響範囲

**例: Dictionary のキャッシング追加**

#### 既存設計
```
変更ファイル:
1. DictionaryStore.swift (実装)
2. RDFStore.swift (呼び出し側)
3. IndexManager.swift (呼び出し側)
4. DictionaryStoreTests.swift (テスト)

影響範囲: 4ファイル
```

#### 新設計
```
変更ファイル:
1. TripleStorage.swift (実装)
2. TripleStorageTests.swift (テスト)

影響範囲: 2ファイル
```

**評価:** 🟢 **新設計が50%少ない**

### 4.4 保守性の評価

| 観点 | 既存設計 | 新設計 | 推奨 |
|------|----------|--------|------|
| **理解しやすさ** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🟢 新設計 |
| **テスト** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 🟢 新設計 |
| **変更の影響** | ⭐⭐ | ⭐⭐⭐⭐⭐ | 🟢 新設計 |
| **デバッグ** | ⭐⭐ | ⭐⭐⭐⭐⭐ | 🟢 新設計 |

---

## 5. 拡張性の比較

### 5.1 将来的な拡張シナリオ

#### シナリオ1: 全文検索インデックスの追加

**既存設計:**
```swift
// 新しいActorを追加
actor FullTextIndexManager { ... }

// IndexManagerを拡張
extension IndexManager {
    func insertWithFullText(...) { ... }
}
```
- ✅ 新しいActorとして分離しやすい
- ✅ 既存コードへの影響小

**新設計:**
```swift
// TripleStorageを拡張
extension TripleStorage {
    func insertWithFullText(...) { ... }
}
```
- ⚠️ TripleStorageが肥大化する可能性
- ✅ ただしextensionで分離可能

**評価:** 🟡 **既存設計がやや有利**（ただし差は小さい）

#### シナリオ2: マルチテナント対応

**既存設計:**
```swift
// DirectoryLayerを追加
// KeySpace/DirectoryLayerの設計が既にある
```
- ✅ Phase 6の設計が既にある

**新設計:**
```swift
// rootPrefixを動的に変更
let storage = TripleStorage(rootPrefix: "tenant_\(tenantID)")
```
- ✅ よりシンプル
- ✅ 既存の設計で対応可能

**評価:** 🟡 **同等**

#### シナリオ3: SPARQL対応

**既存設計:**
```swift
// QueryPlannerが既に存在
// SPARQL → QueryPlan の変換を追加
```
- ✅ QueryPlannerの抽象化が有効

**新設計:**
```swift
// SPARQLParserを追加
// 直接TripleStorage.query()を呼ぶ
```
- ✅ よりシンプル
- ⚠️ 複雑なクエリ最適化が困難

**評価:** 🟡 **既存設計がやや有利**

### 5.2 拡張性の評価

| シナリオ | 既存設計 | 新設計 | 評価 |
|---------|----------|--------|------|
| **全文検索** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 既存設計 |
| **マルチテナント** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 同等 |
| **SPARQL** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 既存設計 |
| **その他** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 🟡 同等 |

**総合評価:** 🟡 **既存設計がやや有利**

ただし：
- ⚠️ Phase 6での拡張時に対応可能
- ⚠️ 現時点では「拡張性」より「シンプルさ」を優先すべき

---

## 6. 実装工数の比較

### 6.1 Phase別の工数見積もり

| Phase | 既存設計 | 新設計 | 差分 |
|-------|----------|--------|------|
| **Phase 1: 基礎** | 2週 | 1週 | **-50%** |
| **Phase 2: コア** | 2週 | 0.5週 | **-75%** |
| **Phase 3: クエリ** | 2週 | 0.5週 | **-75%** |
| **Phase 4: オンライン構築** | 2週 | Phase 6へ延期 | **-100%** |
| **総計（MVP）** | **8週** | **2週** | **-75%** ✅ |

### 6.2 テスト工数

| テスト | 既存設計 | 新設計 | 差分 |
|--------|----------|--------|------|
| **単体テスト** | 30ケース | 10ケース | **-67%** |
| **統合テスト** | 15ケース | 5ケース | **-67%** |
| **総計** | 45ケース | 15ケース | **-67%** ✅ |

### 6.3 ドキュメント工数

| ドキュメント | 既存設計 | 新設計 | 差分 |
|--------------|----------|--------|------|
| **アーキテクチャ** | 既に完成 | 追加1日 | +1日 |
| **API ドキュメント** | 6 Actors | 2 Actors | **-67%** |
| **実装ガイド** | 複雑 | シンプル | **-50%** |

### 6.4 実装工数の評価

**総合:** 🟢 **新設計が圧倒的に有利（75%削減）**

---

## 7. リスク分析

### 7.1 既存設計のリスク

| リスク | 確率 | 影響 | 緩和策 |
|--------|------|------|--------|
| **過剰設計** | 高 | 中 | Phase分けで段階的実装 |
| **実装遅延** | 中 | 高 | 工数8週は長い |
| **保守困難** | 中 | 高 | ドキュメント整備 |
| **Actor間のデッドロック** | 低 | 高 | 慎重な設計 |

### 7.2 新設計のリスク

| リスク | 確率 | 影響 | 緩和策 |
|--------|------|------|--------|
| **4インデックスが不十分** | 低 | 中 | Phase 5で統計収集、必要なら追加 |
| **TripleStorageが肥大化** | 中 | 低 | extensionで分割可能 |
| **シンプルすぎて拡張困難** | 低 | 中 | Phase 6で再設計可能 |
| **パフォーマンス不足** | 低 | 中 | ベンチマーク後に最適化 |

### 7.3 リスク評価

**既存設計:**
- ⚠️ 高リスク：実装遅延、保守困難
- ✅ 低リスク：機能不足

**新設計:**
- ✅ 低リスク：全般的に低リスク
- ⚠️ 中リスク：機能不足の可能性

**評価:** 🟢 **新設計の方がリスクが低い**

---

## 8. 総合評価と推奨

### 8.1 スコアカード

| 評価項目 | 重み | 既存設計 | 新設計 | 重み付きスコア |
|---------|------|----------|--------|---------------|
| **シンプルさ** | 25% | 3/5 | 5/5 | 既存:0.75 新:1.25 |
| **書き込み性能** | 20% | 3/5 | 5/5 | 既存:0.60 新:1.00 |
| **クエリ性能** | 20% | 5/5 | 4/5 | 既存:1.00 新:0.80 |
| **保守性** | 15% | 3/5 | 5/5 | 既存:0.45 新:0.75 |
| **拡張性** | 10% | 5/5 | 4/5 | 既存:0.50 新:0.40 |
| **実装工数** | 10% | 2/5 | 5/5 | 既存:0.20 新:0.50 |
| **合計** | 100% | - | - | **既存:3.50 新:4.70** |

**結果:** 🏆 **新設計（v2.0）が34%高スコア**

### 8.2 ユースケース別の推奨

| ユースケース | 推奨設計 | 理由 |
|-------------|----------|------|
| **MVP開発** | 🟢 新設計 | 2週間で完成 |
| **スタートアップ** | 🟢 新設計 | シンプルで保守しやすい |
| **大企業** | 🟡 既存設計 | 豊富な機能、拡張性 |
| **研究プロジェクト** | 🟢 新設計 | 迅速なプロトタイピング |
| **本番環境（大規模）** | 🟡 状況による | ベンチマーク後に判断 |

### 8.3 最終推奨

**🏆 推奨: 新設計（v2.0）を採用**

**理由:**
1. ✅ **圧倒的にシンプル**（コード50%削減）
2. ✅ **高速な実装**（2週間でMVP）
3. ✅ **保守しやすい**（1つのActorで完結）
4. ✅ **十分な性能**（97%のクエリで同等）
5. ✅ **低リスク**（必要なら後で拡張可能）

**ただし条件付き:**
- ⚠️ Phase 5でベンチマークを実施
- ⚠️ `(s, ?, o)` クエリの使用頻度を実測
- ⚠️ 問題があればPhase 6で既存設計の要素を追加

---

## 9. 実装計画（新設計ベース）

### Phase 1: MVP (Week 1-2) 🎯

```swift
// 実装するもの
- RDFTriple struct
- TripleStorage actor
  - insert/delete/query
  - Dictionary (URI↔ID)
  - 4 indexes (SPO, PSO, POS, OSP)
  - Basic metadata

// 目標
- 動作するトリプルストア
- 10,000 トリプル/秒の書き込み
- < 10ms のクエリレイテンシ
```

### Phase 2: キャッシング (Week 3)

```swift
// 実装するもの
- LRU cache for URI→ID
- Metadata cache

// 目標
- 50,000 トリプル/秒の書き込み
```

### Phase 3: バッチ操作 (Week 4)

```swift
// 実装するもの
- insertBatch
- deleteBatch

// 目標
- 100,000 トリプル/秒のバッチ書き込み
```

### Phase 4: ベンチマーク & 評価 (Week 5)

```swift
// 実施すること
- 1億トリプルでのベンチマーク
- クエリパターンの頻度分析
- (s, ?, o) パターンの実測

// 判断基準
- (s, ?, o) が全体の1%未満 → 4インデックスで十分
- (s, ?, o) が全体の5%以上 → SOPインデックス追加
```

### Phase 5: 最適化 (Week 6)

```swift
// 実装するもの（必要に応じて）
- 統計情報収集
- クエリキャッシング
- パフォーマンスチューニング
```

### Phase 6: 高度な機能 (Week 7+)

```swift
// 検討するもの
- IndexBuilder (必要なら)
- SPARQL parser
- 全文検索
- マルチテナント
```

---

## 10. まとめ

### 10.1 重要な発見

1. **6インデックスは過剰**
   - 97%のクエリは4インデックスでカバー可能
   - 33%の書き込み性能向上

2. **Actor分割は過剰**
   - 単一のTripleStorage Actorで十分
   - 50%のコード削減

3. **RangeSet/Throttleは時期尚早**
   - シンプルな実装で実用上十分
   - 必要になったら追加可能

4. **シンプルさが最優先**
   - 拡張性より保守性
   - MVPを迅速に完成させることが重要

### 10.2 設計哲学の教訓

> "Premature optimization is the root of all evil." - Donald Knuth

既存設計（v1.2）は、将来の全ての可能性に備えようとして複雑になった。
新設計（v2.0）は、今必要な機能のみを実装し、将来の拡張は必要になってから対応する。

**結論:**
🏆 **新設計（v2.0）を採用し、Phase 1から実装を開始することを推奨します。**

---

**Next Steps:**
1. ✅ 新設計（v2.0）の採用を決定
2. ⏭️ Phase 1の実装を開始
3. ⏭️ Phase 4でベンチマーク実施
4. ⏭️ 結果に基づいて Phase 5-6を計画
